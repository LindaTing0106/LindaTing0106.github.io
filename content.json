{"meta":{"title":"Linda's Blog","subtitle":"...","description":"","author":"Linda Ting","url":"http://LindaTing0106.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-10-30T05:35:36.000Z","updated":"2021-10-30T05:37:29.558Z","comments":true,"path":"categories/index.html","permalink":"http://lindating0106.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-10-30T05:41:03.000Z","updated":"2021-11-03T14:56:45.805Z","comments":true,"path":"about/index.html","permalink":"http://lindating0106.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-30T05:39:46.000Z","updated":"2021-10-30T05:40:07.819Z","comments":true,"path":"tags/index.html","permalink":"http://lindating0106.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OpenCV Foundation","slug":"OpenCV-Foundation","date":"2021-11-03T13:05:59.000Z","updated":"2021-11-04T08:14:45.015Z","comments":true,"path":"2021/11/03/OpenCV-Foundation/","link":"","permalink":"http://lindating0106.github.io/2021/11/03/OpenCV-Foundation/","excerpt":"OpenCV做基本讀取圖片、寫入圖片等功能引入 python 模組12import numpy as npimport cv2 使用 cv2 讀取圖片以 cv2.imread 讀進來的資料，會儲存成一個 NumPy 的陣列。 1cv2.imread(&quot;image.jpg&quot;) NumPy 陣列的前兩個維度分別是圖片的高度與寬度，第三個維度則是圖片的 channel（RGB 彩色圖片的 channel 是 3，灰階圖片則為 1）。","text":"OpenCV做基本讀取圖片、寫入圖片等功能引入 python 模組12import numpy as npimport cv2 使用 cv2 讀取圖片以 cv2.imread 讀進來的資料，會儲存成一個 NumPy 的陣列。 1cv2.imread(&quot;image.jpg&quot;) NumPy 陣列的前兩個維度分別是圖片的高度與寬度，第三個維度則是圖片的 channel（RGB 彩色圖片的 channel 是 3，灰階圖片則為 1）。 圖片格式OpenCV 的 cv2.imread 在讀取圖片時，可以在第二個參數指定圖片的格式，可用的選項有三種： cv2.IMREAD_COLOR此為預設值，這種格式會讀取 RGB 三個 channels 的彩色圖片，而忽略透明度的 channel。cv2.IMREAD_GRAYSCALE以灰階的格式來讀取圖片。cv2.IMREAD_UNCHANGED讀取圖片中所有的 channels，包含透明度的 channel。 12# 以灰階的方式讀取圖檔img_gray = cv2.imread(&#x27;image.jpg&#x27;, cv2.IMREAD_GRAYSCALE) 顯示圖片12# 顯示圖片cv2.imshow(&#x27;My Image&#x27;, img) 123# 按下任意鍵則關閉所有視窗cv2.waitKey(0)cv2.destroyAllWindows() 寫入圖片檔案12# 寫入圖檔cv2.imwrite(&#x27;output.jpg&#x27;, img) 123# 寫入不同圖檔格式cv2.imwrite(&#x27;output.png&#x27;, img)cv2.imwrite(&#x27;output.tiff&#x27;, img) 調整圖片裁切部分圖片12345# extract a 100x100 pixel square ROI (Region of Interest) from the# input image starting at x=320,y=60 at ending at x=420,y=160roi = image[60:160, 320:420]cv2.imshow(&quot;ROI&quot;, roi)cv2.waitKey(0) image[startY:endY, startX:endX] 調整圖片大小1234# resize the image to 200x200px, ignoring aspect ratioresized = cv2.resize(image, (200, 200))cv2.imshow(&quot;Fixed Resizing&quot;, resized)cv2.waitKey(0) 如果原本圖片比率為 3 : 4，而後來需要調整成 1 : 1的圖片，則調整過後的圖片會被壓扁。 1234567# fixed resizing and distort aspect ratio so let&#x27;s resize the width# to be 300px but compute the new height based on the aspect ratior = 300.0 / wdim = (300, int(h * r))resized = cv2.resize(image, dim)cv2.imshow(&quot;Aspect Ratio Resize&quot;, resized)cv2.waitKey(0) 利用運算得出寬度縮放比率，再推導出高。 12345# manually computing the aspect ratio can be a pain so let&#x27;s use the# imutils library insteadresized = imutils.resize(image, width=300)cv2.imshow(&quot;Imutils Resize&quot;, resized)cv2.waitKey(0) 利用imutils套件讓原比例縮放變得更容易。 旋轉圖片12345678# let&#x27;s rotate an image 45 degrees clockwise using OpenCV by first# computing the image center, then constructing the rotation matrix,# and then finally applying the affine warpcenter = (w // 2, h // 2)M = cv2.getRotationMatrix2D(center, -45, 1.0)rotated = cv2.warpAffine(image, M, (w, h))cv2.imshow(&quot;OpenCV Rotation&quot;, rotated)cv2.waitKey(0) center = (w // 2, h // 2)目的是在於算出整數（忽略 float）。M = cv2.getRotationMatrix2D(center, -45, 1.0)設定中心點 旋轉角度 縮放倍率。rotated = cv2.warpAffine(image, M, (w, h))真正對圖片去做更改。 1234# rotation can also be easily accomplished via imutils with less coderotated = imutils.rotate(image, -45)cv2.imshow(&quot;Imutils Rotation&quot;, rotated)cv2.waitKey(0) 使用imutils套件。 但在以上兩種方法中，我們可以發現選轉過後的圖片會超過顯示器的邊界，因此我們可以用以下方式： 123456# OpenCV doesn&#x27;t &quot;care&quot; if our rotated image is clipped after rotation# so we can instead use another imutils convenience function to help# us outrotated = imutils.rotate_bound(image, 45)cv2.imshow(&quot;Imutils Bound Rotation&quot;, rotated)cv2.waitKey(0) 模糊圖片12345# apply a Gaussian blur with a 11x11 kernel to the image to smooth it,# useful when reducing high frequency noiseblurred = cv2.GaussianBlur(image, (11, 11), 0)cv2.imshow(&quot;Blurred&quot;, blurred)cv2.waitKey(0) 在圖片上畫畫1234output = image.copy()cv2.rectangle(output, (320, 60), (420, 160), (0, 0, 255), 2)cv2.imshow(&quot;Rectangle&quot;, output)cv2.waitKey(0) img : The destination image to draw upon. We’re drawing on output . pt1 : Our starting pixel coordinate which is the top-left. In our case, the top-left is (320, 60) . pt2 : The ending pixel — bottom-right. The bottom-right pixel is located at (420, 160) . color : BGR tuple. To represent red, I’ve supplied (0 , 0, 255) . thickness : Line thickness (a negative value will make a solid rectangle). I’ve supplied a thickness of 2 .因為我們現在是在控制 cv2 的 function，所以參數放置型態為 (x,y)，而不是 (y,x)。畫一個實心的圓圈：123456# draw a blue 20px (filled in) circle on the image centered at# x=300,y=150output = image.copy()cv2.circle(output, (300, 150), 20, (255, 0, 0), -1)cv2.imshow(&quot;Circle&quot;, output)cv2.waitKey(0) cv2.circle(output, (300, 150), 20, (255, 0, 0), -1)中的-1代表填滿的意思。在圖中畫線：12345# draw a 5px thick red line from x=60,y=20 to x=400,y=200output = image.copy()cv2.line(output, (60, 20), (400, 200), (0, 0, 255), 5)cv2.imshow(&quot;Line&quot;, output)cv2.waitKey(0) 在圖中輸入文字：123456# draw green text on the imageoutput = image.copy()cv2.putText(output, &quot;OpenCV + Jurassic Park!!!&quot;, (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)cv2.imshow(&quot;Text&quot;, output)cv2.waitKey(0) img : The output image. text : The string of text we’d like to write/draw on the image. pt : The starting point for the text. font : I often use the cv2.FONT_HERSHEY_SIMPLEX . The available fonts are listed here. scale : Font size multiplier. color : Text color. thickness : The thickness of the stroke in pixels.結合其他功能導入圖片123456789# import the necessary packagesimport argparseimport imutilsimport cv2# construct the argument parser and parse the argumentsap = argparse.ArgumentParser()ap.add_argument(&quot;-i&quot;, &quot;--image&quot;, required=True, help=&quot;path to input image&quot;)args = vars(ap.parse_args()) argparse讓使用者能在不改變原始碼的情況下，編譯器不同的檔案。ap.add_argument(&quot;-i&quot;, &quot;--image&quot;, required=True, help=&quot;path to input image&quot;) 如要執行此程式，需在 cmd 中輸入 $python filename.py -i imagepath，就能成功地將需要的圖片放入編譯器中。圖片被存在args[“image”]中。將剛剛導入的圖片轉成灰階123456789# load the input image (whose path was supplied via command line# argument) and display the image to our screenimage = cv2.imread(args[&quot;image&quot;])cv2.imshow(&quot;Image&quot;, image)cv2.waitKey(0)# convert the image to grayscalegray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)cv2.imshow(&quot;Gray&quot;, gray)cv2.waitKey(0) 偵測圖片邊緣12345# applying edge detection we can find the outlines of objects in# imagesedged = cv2.Canny(gray, 30, 150)cv2.imshow(&quot;Edged&quot;, edged)cv2.waitKey(0) cv2.Canny function: img : The gray image. minVal : A minimum threshold, in our case 30 . maxVal : The maximum threshold which is 150 in our example. aperture_size : The Sobel kernel size. By default this value is 3 and hence is not shown .影像分割_二值化123456# threshold the image by setting all pixel values less than 225# to 255 (white; foreground) and all pixel values &gt;= 225 to 255# (black; background), thereby segmenting the imagethresh = cv2.threshold(gray, 225, 255, cv2.THRESH_BINARY_INV)[1]cv2.imshow(&quot;Thresh&quot;, thresh)cv2.waitKey(0) using cv2.THRESH_BINARY_INV，使閥值大於225的pixels變成黑色 (0)，而閥值小於225的pixels變成白色 (255)。 255為最大灰階值，如調成 200，則白色變為灰色。偵測和畫輪廓線沿用剛剛已二值化的圖像。12345678910111213# find contours (i.e., outlines) of the foreground objects in the# thresholded imagecnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)cnts = imutils.grab_contours(cnts)output = image.copy()# loop over the contoursfor c in cnts: # draw each contour on the output image with a 3px thick purple # outline, then display the output contours one at a time cv2.drawContours(output, [c], -1, (240, 0, 159), 3) cv2.imshow(&quot;Contours&quot;, output) cv2.waitKey(0) cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)其中第二個參數放置輪廓的搜索模式： cv2.RETR_LIST：檢測的輪廓不建立等級關係（沒有父輪廓、內嵌輪廓） cv2.RETR_TREE：建立一個等級樹結構的輪廓。 cv2.RETR_CCOMP：建立兩個等級的輪廓，上面的一層為外邊界，裡面的一層為內層的邊界資訊，若內層中還有輪廓，則這個輪廓被歸類為頂層。 cv2.RETR_EXTERNAL：表示只檢測外輪廓。第三個參數為輪廓的近似辦法： cv2.CHAIN_APPROX_NONE：儲存所有的輪廓點，相鄰的兩個點的畫素位置差不超過1，即max（abs（x1-x2），abs（y2-y1））==1。 cv2.CHAIN_APPROX_SIMPLE：只存轉彎角的資訊。 cv2.CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似演算法。顯示出圖上有幾個物件：123456# draw the total number of contours found in purpletext = &quot;I found &#123;&#125; objects!&quot;.format(len(cnts))cv2.putText(output, text, (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (240, 0, 159), 2)cv2.imshow(&quot;Contours&quot;, output)cv2.waitKey(0) 壓縮和擴張12345# we apply erosions to reduce the size of foreground objectsmask = thresh.copy()mask = cv2.erode(mask, None, iterations=5)cv2.imshow(&quot;Eroded&quot;, mask)cv2.waitKey(0) 把二值化圖的物件大小縮小5 iterations。12345# similarly, dilations can increase the size of the ground objectsmask = thresh.copy()mask = cv2.dilate(mask, None, iterations=5)cv2.imshow(&quot;Dilated&quot;, mask)cv2.waitKey(0) 把二值化圖的物件大小放大5 iterations。Masking and bitwise operations1234567# a typical operation we may want to apply is to take our mask and# apply a bitwise AND to our input image, keeping only the masked# regionsmask = thresh.copy()output = cv2.bitwise_and(image, image, mask=mask)cv2.imshow(&quot;Output&quot;, output)cv2.waitKey(0) 參考資料：https://www.pyimagesearch.com/2018/07/19/opencv-tutorial-a-guide-to-learn-opencv/","categories":[],"tags":[],"author":"Linda Ting"},{"title":"To-Do list","slug":"To-Go list","date":"2021-10-29T17:59:44.000Z","updated":"2021-11-02T09:51:57.681Z","comments":true,"path":"2021/10/30/To-Go list/","link":"","permalink":"http://lindating0106.github.io/2021/10/30/To-Go%20list/","excerpt":"","text":"202111/01 ~ 11/07 看完大型電路機體進度 讀完下禮拜論文 找尋影像辨識資料 人機作業","categories":[{"name":"Main","slug":"Main","permalink":"http://lindating0106.github.io/categories/Main/"}],"tags":[{"name":"ToDoList","slug":"ToDoList","permalink":"http://lindating0106.github.io/tags/ToDoList/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-28T16:20:00.716Z","updated":"2021-10-28T16:20:00.717Z","comments":true,"path":"2021/10/29/hello-world/","link":"","permalink":"http://lindating0106.github.io/2021/10/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Main","slug":"Main","permalink":"http://lindating0106.github.io/categories/Main/"}],"tags":[{"name":"ToDoList","slug":"ToDoList","permalink":"http://lindating0106.github.io/tags/ToDoList/"}]}